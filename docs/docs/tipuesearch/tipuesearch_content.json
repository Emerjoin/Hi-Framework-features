{"pages":[{"title":"Hi-Framework","text":"What is Hi-Framework? An Ajax MVC Java EE Framework based on AngularJS Say &quot;Hello&quot; to your Client-Side","tags":"","url":"index.html"},{"title":"Introduction","text":"What is Hi-Framework? Is a light Java Framework that allows developers to write fully Ajax web applications combining the power of a Java back-end to a rich client-side powered by AngularJS. What do you gain in Hi-Framework? Ajax out-of-the-box The entire application is AJAX and its not even optional. HTML and JavaScript as you met them Views are pure HTML files and they can only be manipulated from JavaScript and never from Java. Save java for the back-end job. Routing No hashbang URLS. Clean and comprehensive URLS. No need to use angular router. No need to write Web-services Call java methods from JavaScript and reach you back-end instantly enabling easy testability. Back-end and front-end in the same project One deploy. What do you need to get started? JAVA (version 1.8) Want to contribute? Email the Hi-Framework team via emerjoin@gmail.com","tags":"","url":"Getting_started\/Introduction.html"},{"title":"Application structure and components","text":"Hi-Framework is not concerned about how you manage your java source files. It is only concerned about the web directory. The web directory structure |-- Web |-- WEB-INF |-- hi.xml |-- webroot |-- views |-- templateName.html |-- templateName.js If you are familiar with JavaEE web applications you might have noticed that Hi-framework does not change the structure, it just adds few directories and a configuration file within WEB-INF directory. Lets now understand the purpose of each file\/directory. WEB-INF\/hi.xml This is the framework configuration file. Your application is configured here. webroot This is the assets home. The directory holds scripts, stylesheets, images and all the files that should be publicly accessible. views This is where the view files live. A View is displayed uppon Controller invocation as stated by MVC pattern. templateName.js and templateName.html This templateName.html file is the container within which the view files are displayed. The templateName.js listens some events that will be detailled later. NOTE: You are completely free to add your own directories and files according to your needs, as long as the directory structure demanded by the framework remains in place.","tags":"","url":"Getting_started\/Application_structure_and_components.html"},{"title":"Preparing the environment","text":"Setting up the maven project Hi-Framework is not in maven central repository, meaning that you have to add our maven repository to your POM so that the dependency can be resolved. The following snippet should be added to your POM file: &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;talk-code&lt;\/id&gt; &lt;name&gt;maven-repo&lt;\/name&gt; &lt;url&gt;https:\/\/github.com\/talk-code\/maven-repo\/raw\/master&lt;\/url&gt; &lt;\/repository&gt; &lt;\/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mz.hi.framework&lt;\/groupId&gt; &lt;artifactId&gt;hi-web&lt;\/artifactId&gt; &lt;version&gt;1.4.6-beta-SNAPSHOT&lt;\/version&gt; &lt;\/dependency&gt; &lt;\/dependencies&gt; If you already have a repositories element on your POM file, make sure you only copy the repository into your POM, the same applies to the dependencies and dependency elements. Adding Mandatory JavaEE dependencies to maven project CDI 1.2 Implementation Hi-Framework depends on the CDI API. There should be a CDI Implementation (version 1.2) in your classpath when attempting to deploy the application. If you are using Glassfish, make sure it has the correct implementation before you run into trouble. If your Glassfish (or any other JavaEE server) is not shipped with any CDI 1.2 implementation, we recommed you to add the JBoss Weld 2.1 implementation of CDI to your application's classpath. This can be done using the following maven dependency: &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld&lt;\/groupId&gt; &lt;artifactId&gt;weld-core&lt;\/artifactId&gt; &lt;version&gt;2.1.0.Final&lt;\/version&gt; &lt;\/dependency&gt;","tags":"","url":"Getting_started\/The Hello_World_App\/Preparing_the_environment.html"},{"title":"Creating the Hello controller and world view","text":"Controller definition Before we go any further, lets define a Controller. The user interacts with the system navigating through URLs. Earch url, is used to retrieve interactive content and points to an action of a Controller. The URLs format is: controller-name\/action-name. A controller is a managed bean that extends the mz.co.hi.web.mvc.Controller class. All public methods of a controller are considered actions, meaning they are accessible via URL. What we want to do now, is to create a web application that displays a Hello World message after entering the URL hello\/world on the browser. Lets see how the Hello.java controller file should look like: package my.controllers; \/\/your controllers's package can have any name import mz.co.hi.web.mvc.Controller; import mz.co.hi.web.mvc.exceptions.MvcException; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class Hello extends Controller { public void world() throws MvcException{ this.callView(); } } The instruction this.callView() basically tells Hi-Framework to load a view and display it to the user. A view should be created in order to have that line of code executing successfully. So, how do you create a view? The View It is composed by two files: a html file and its correspondent javascript file. These two files should have the same name as the action that calls them, and they must be placed under the views directory, according to the following directories structure: |-- Web |-- views |-- hello |-- world.html |-- world.js Notice that we created a directory with the controller's name &quot;hello&quot; and then we created two files under that directory. That two files represent the view. NOTE: the view directories must be a mirror of the url. Meaning: 1. no capital letters 2. camelCase is converted to hyphen separed words. Ex: hiFramework = hi-framework HiFramework = hi-framework world.html This file contains markup content to be loaded and renderized on browser for the hello\/world URL. &lt;div&gt; &lt;h1&gt;Hello world&lt;\/h1&gt; &lt;\/div&gt; world.js This file contains javascript code that manipulates the markup content, before, during and after its renderization. Hi.view(function($scope){ \/\/Body empty for now });","tags":"","url":"Getting_started\/The Hello_World_App\/Creating_the_Hello_controller_and_world_view.html"},{"title":"Creating the template","text":"Template definition Template is what surrounds your views. The views are diplayed within templates. On facebook for example, you can notice that the top bar is present in every single page. Thats because it is part of the facebook template. A template has a defined area within which, the views are displayed. Each template in Hi, is composed by two files: html and javascript, same as views. Hi-Framework allows you to have more than one template and switch between them as you need. For now, lets focus on creating our default template. The name of the template we are going to create is index, tha's because Hi recognises index as the default template. You may a bunch of templates with other names but one of them must be named &quot;index&quot;. The html file of a template is responsible for loading every single script,image,stylesheet or any other asset the application depends on. Views should not include scripts or sytlesheets. The template files should be placed inside the web root(not &quot;webroot&quot;) directory, being direct childs of it. Lets see how our web directory looks like, after creating the index template files: |-- Web |-- WEB-INF |-- web.xml |-- hi.xml |-- webroot |-- views |-- index.html |-- index.js Let's see how these files are composed. index.html This is the markup file of our default template. This file has to include at least 3 things jquery script (greater or equal to 1.10 ) The hi-framework script The place where views should be included. Thiss next code block will show you how to do it: &lt;html&gt; &lt;head&gt; &lt;title&gt;Hi-Framework | Getting started&lt;\/title&gt; &lt;!--The jquery script--&gt; &lt;script src=&quot;https:\/\/code.jquery.com\/jquery-3.0.0.min.js&quot;&gt;&lt;\/script&gt; &lt;!--The hi-framework script--&gt; &lt;script src=&quot;hi-es5.js&quot;&gt;&lt;\/script&gt; &lt;\/head&gt; &lt;body&gt; Template content comes here &lt;!--The views will placed inside this div--&gt; &lt;div id=&quot;view_content&quot;&gt;{{view_content}}&lt;\/div&gt; &lt;\/body&gt; &lt;\/html&gt; IMPORTANT RULE: The jquery script should always be included before the hi-framework script and they should both be placed as childs of head element. Feel free to add your own scrips, stylesheets and anything else you want. This a normal html file. Make sure you place your assets (scripts, stylesheets, images) under the webroot directory. The internal structure of the webroot directory is on you. Create as many folders and files as you need. If you are going to download the jquery to your application, you should store it under the webroot directory, in a subdirectory of your own choice. For example: |-- Web |-- WEB-INF |-- web.xml |-- hi.xml |-- webroot |-- js |-- jquery-3.0.0.min.js |-- views |-- index.html |-- index.js You would then have to change the jquery script path in your index.html file to: &lt;script src=&quot;webroot\/js\/jquery-3.0.0.min.js&quot;&gt;&lt;\/script&gt; You can load any asset in your template. Just make sure you put the right path, starting with &quot;webroot&quot; and following the directories strucuture. index.js This file is designated template controller. Lets not get into too much details about this now. What matters most at this step is the content of the file, which is: Hi.template({ \/\/Empty body for now });","tags":"","url":"Getting_started\/The Hello_World_App\/Creating_the_template.html"},{"title":"Creating the config file","text":"What is the configuration file? Its a XML file that configures the behavoir of Hi-Framework regarding your application. The configuration file for our Hello world app &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;app xmlns=&quot;http:\/\/hi.co.mz\/XMLSchema&quot; xmlns:xsi=&quot;http:\/\/www.w3.org\/2001\/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http:\/\/hi.co.mz\/XMLSchema https:\/\/talk-code.github.io\/releases\/ns\/hi-1.0.xsd&quot;&gt; &lt;web&gt; &lt;welcome-url&gt;hello\/world&lt;\/welcome-url&gt; &lt;\/web&gt; &lt;\/app&gt; There is no mandatory configuration to run your Hi app. In order to make the root URL of your application display a specific view, you should configure your welcome-url as it's done in the snipped above. Check bellow some assumptions Hi makes: The default template is named index The default directory for views is named views Where is the config file located? The configuration file should be placed under the WEB-INF directory and must have the name hi.xml. What else? Our web application is ready for reployment. But we may want review our files and directories structure. Putting it all together, we must have : |-- Web |-- WEB-INF |-- hi.xml |-- webroot |-- js |-- jquery-3.0.0.min.js |-- views |-- hello |-- world.html |-- world.js |-- index.html |-- index.js |-- java [--] my.controlles |-- Hello.java NOTE: The configuration file is not optional. An attempt of deployment without the configuration file will result in errors. You can now build and deploy the application","tags":"","url":"Getting_started\/The Hello_World_App\/Creating_the_config_file.html"},{"title":"Testing the app","text":"BASE_URL\/hello\/world BASE_URL is defined by your server host + port and the name of your application (context path) within the server you deployed it to. Example of BASE URL: http:\/\/localhost:8080\/app1. The full URL would be: http:\/\/localhost:8080\/app1\/hello\/world The outcome","tags":"","url":"Getting_started\/The Hello_World_App\/Testing_the_app.html"},{"title":"Navigation","text":"You wouldn't put all your business logic in a single view, would you? Lets create a new action and then figure out how can we redirect the user from one view to another. The second action Adding the action method Just add the following code fragment to the Hello controller source code file. public void second() throws MvcException{ this.callView(); } Creating the view for the new action All we have to do is: create two files under the directory views\/hello\/: |-- views |-- Hello |-- world.html |-- world.js |-- second.html |-- second.js second.html &lt;div&gt; &lt;h2&gt;Second action&lt;\/h2&gt; &lt;!--This will redirect the user to hello\/world using ajax--&gt; &lt;a href=&quot;hello\/world&quot; ajaxify&gt;Go back&lt;\/a&gt; &lt;\/div&gt; NOTE: The ajaxify attribute used above, configures the hyperlink element to perform an ajax redirect onClick. second.js Hi.view(function($scope){ }); Adding a redirect link to the views\/hello\/world.html file (method 1) The modified views\/hello\/world.html version: &lt;div&gt; &lt;h1&gt;Hello world&lt;\/h1&gt; &lt;a href=&quot;hello\/second&quot; ajaxify&gt;Go to second&lt;\/a&gt; &lt;\/div&gt; User can now navigate from hello\/world to hello\/second and vice versa. Just rebuild the application and redeploy it. Results Adding a redirect link to the views\/hello\/world.html file (method 2) Let's change again our world.html file. The modified views\/hello\/world.html version: &lt;div&gt; &lt;h1&gt;Hello world&lt;\/h1&gt; &lt;button ng-click=&quot;goToSecond()&quot;&gt;Go to second&lt;\/button&gt; &lt;\/div&gt; We basically changed our hyperlink to a button. This button calls a function named goToSecond on a click. The ng-click tag is part of AngularJS. You can consult more about Angular anywhere in the internet. Now, let's change our world.js file. The modified views\/Hello\/world.js version: . Hi.view(function($scope){ $scope.goToSecond = function(){ Hi.redirect(&quot;hello\/second&quot;); } }); We created in the $scope of our javascript view, a fuction that uses a special method called redirect witch redirects the user the same way as the first aproach. Test it! it will work the same way!","tags":"","url":"Getting_started\/Navigation.html"},{"title":"Frontiers basics","text":"The concept Frontiers are special classes that can be accessed from client-side. The methods of frontier classes are accessed as if they were declared as static. The rules Frontier classes are Managed beans (same as controllers). All frontiers must be annotated with the @Frontier annotation Frontier methods are suposed to return data. void methods are not considered frontiers methods The example frontier Example.java package my.frontiers; import javax.enterprise.context.ApplicationScoped; import java.util.HashMap; import java.util.Map; import mz.co.hi.web.meta.Frontier; @Frontier @ApplicationScoped public class Example { public String basic() { return &quot;This is a frontier message&quot;; } public Map increment(int value) { Map map = new HashMap(); map.put(&quot;incremented&quot;,value+1); return map; } } We created a frontier named Example and within it two methods: basic and increment. Both methods return messages, basic returns a String with a static message and increment a java.util.Map with a dynamic one. We added Example.java to a package named frontiers that resides inside a package named my. Let's see how do we invoke these methods. Invoking the frontier methods from javascript To invoke frontier methods, we have to do as following from anypoint in your javascript: FrontierName.frontierMethod().try(function(result){ console.log(result.message); }); Calling the example frontier from world.js view Let's go back to our world.js view and take a look at it: Hi.view(function($scope){ $scope.goToSecond = function(){ Hi.redirect(&quot;hello\/second&quot;); } }); So, what we have here? Remember: Javascript views handle events fired by markup elements in html views In the snippet above, we can see a function named goToSecond. Now we will change the behavior of this function and make it call a frontier method. Let's change the world.js view and make it look like this: Hi.view(function($scope){ $scope.goToSecond = function(){ Example.basic().try(function(result){ alert(result); }); } }); Now, if you click the button Go to second in the route hello\/world, instead of redirecting your application, the click event will show an alert with the message returnerd by the basic method of the example frontier Well, now you can test your application. But before, read the following tips: Tips Rebuild and redeploy your application Everytime you change a frontier Reload the page after redeployment. Passing params on a frontier method call Adding a button to a view html &lt;button ng-click=&quot;frontierMessage(5)&quot;&gt;Click on me&lt;\/button&gt; Adding the frontierTest function The frontierMessage function shoud be added to the $scope object of the view where the button element was placed. If you dont understand anything about angular-js scopes, please follow this link to get started and please come back only after understanding the basics. Hi.view(function($scope){ $scope.frontierMessage = function(number){ Example.increment(number).try(function(result){ alert(result.incremented); }); }; }); Feel free to make any changes to your app at this point. Remeber the tips. Use any other framework for any other purprose. For a deep understanding, read the Core Concepts ahead. ;)","tags":"","url":"Getting_started\/Frontiers_basics.html"},{"title":"Core Concepts","text":"Welcome to our Core Concepts Here you will have a understanting of the core components of Hi-Framework. Everthging explained in the Getting Started section will also be explained here but, with more details and complexity. If you didn't read the Getting Started you may have some big issues here. Ready to move on? Press \"Next\" and dive into Controllers","tags":"","url":"Core_Concepts\/index.html"},{"title":"Controllers","text":"By now, you already know controllers. Definition Controllers are part of the MVC-Pattern. In Hi, Controllers are responsible to handle requests made to it's methods witch are responsible for calling views. A controller is a managed bean that extends the mz.co.hi.web.mvc.Controller class. All public methods of a controller are considered actions, meaning that they are accessible via URL. Actions Actions are Controller methods. They are responsible for calling the views. They comunicate with your server-resources and pass data to your client-side. The rules Controllers classes are Managed beans Controllers extend the mz.co.hi.web.mvc.Controller class Actions must be void (Diferrent from Frontier methods) Convetions Naming Controllers Controllers are Java Classes and we recommend you to name them as the best pratices recommend us to name Java Classes. See Examples: Hello, HiWorld Naming Actions Methods must follow the camelCase pattern No underscore or hyphen will be accepted See Examples: hi, helloWorld The Example Controller package my.controllers; \/\/your controllers's can be in multiple packages (packages with any name) import mz.co.hi.web.mvc.Controller; import mz.co.hi.web.mvc.exceptions.MvcException; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class Example extends Controller { public void myAction() throws MvcException{ this.callView(); } } In the snipped above, we have a Controller named &quot;Example&quot; and an action named &quot;myAction&quot; You can have as many actions as we need. Actions must throw a MvcException. The this.callView() instruction, tells Hi-Framework to find 2 view files in the directory &quot;examaple&quot; (Controller Name). These files must be my-action.js and my-action.js |-- views |-- example |-- my-action.html |-- my-action.js About the naming convetions to view files and directories: all must be lowercase the case-chages must be replaced by hyphens How to send data to your views from your actions? Well, that's the question now! How do you send data to views?. Actions cant just call views, they must be able to tell the views what data to work with. That's what this topic is about. What to know? You send data to views, by passing a java.util.Map Object to the callView method The keys in the java.util.Map Object you are going to create, will be converted to variables in your view's Scope Got it? Hope this examaple explains! package my.controllers; \/\/your controllers's can be in multiple packages (packages with any name) import mz.co.hi.web.mvc.Controller; import mz.co.hi.web.mvc.exceptions.MvcException; import java.util.HashMap; import java.util.Map; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class Example extends Controller { public void myAction() throws MvcException{ Map dataToSend = new HashMap(); dataToSend.put(&quot;message&quot;,&quot;Hi Coders! Iam going to be on a angular variable of my-action Scope!&quot;); dataToSend.put(&quot;number&quot;,23); this.callView(dataToSend); } } my-action.html In the views, you should display the data as Angular JS template engine teachs you. Feel free to use it as you like &lt;div&gt; &lt;h1&gt;The message is {{message}} and the number is &lt;b&gt;{{number}}&lt;\/b&gt;&lt;\/h1&gt; &lt;\/div&gt; my-action.js We will automatically create two variables here. $scope.message and $scope.number Hi.view(function($scope){ $scope.$postLoad = function(){ alert($scope.number+&quot; &quot;+$scope.message); } }); NOTE: The $postLoad function comes with Hi-Framework, along with others. $postLoad is executed as soon as the view markup is fully loaded How to get passed data from params? This is one of the easiest things to do. As you may noticed by now, Frontiers can return any kind of data to client-side. and it also receives data of any kind from client-side(as params). Controllers are different, they work with Map Objects. Map-in and Map-out Actions(Controller methods), only receive one param. A java.util.Map Object. That object will contain the value of params Wait... Let me make something clear first. Hi Framework only works with query-strings for URL params Now you may undestand the use of maps. Take this url for instance: http:\/\/localhost:8080\/MyApp\/example\/my-action?name=Greetings&amp;details=Hello public void myAction(Map params) throws MvcException{ Map dataToSend = new HashMap(); dataToSend.put(&quot;message&quot;,params.get(&quot;name&quot;)); \/\/Now we are setting &quot;Greetings&quot; as our message dataToSend.put(&quot;number&quot;,23); this.callView(dataToSend); } How to send data to template? Hi Framework has a way for you to manipulate your client-side state from the server-side. This manipulation can be done using the class import mz.co.hi.web.FrontEnd Injecting FrontEnd In order to use the FrontEnd class, we need to Inject it to our Controller(or Frontier) using the @Inject annotation from CDI. package my.controllers; \/\/your controllers's can be in multiple packages (packages with any name) import mz.co.hi.web.mvc.Controller; import mz.co.hi.web.mvc.exceptions.MvcException; import mz.co.hi.web.FrontEnd; import javax.enterprise.context.ApplicationScoped; import javax.inject.Inject; @Inject FrontEnd frontEnd; @ApplicationScoped public class Example extends Controller { public void myAction() throws MvcException{ this.callView(); } } After Injecting the FrontEnd class, you are free to explore all of it's methods. But for now let's see how we can pass data to the template public void myAction(Map params) throws MvcException{ Map templateData = new HashMap(); templateData.put(&quot;message&quot;, &quot;Iam going to the template!&quot;); frontEnd.setTemplateData(templateData); this.callView(); } In the template you must use the variables as they are used in views. same logic. If you have troubles with this, read more about &quot;templates&quot; in the next sections. index Actions If you have an action named index, then it doesn't become mandatory to reffrence it in the URL. meaning that, In the HelloController, you can access the index action with theses urls: localhost:8080\/MyAPP\/hello\/index localhost:8080\/MyAPP\/hello Restricting Access of Controller Just use the @Granted annotation! @ApplicationScoped @Granted({&quot;ROLE1&quot;,&quot;ROLE2&quot;}) \/\/Only users with these roles can access @ApplicationScoped public class Example extends Controller { @Granted(&quot;ROLE3&quot;) \/\/Only users with this role can access public void myAction() throws MvcException{ this.callView(); } }","tags":"","url":"Core_Concepts\/Controllers.html"},{"title":"Views","text":"A view is composed by two files: a html file and its correspondent javascript file. These two files should have the same name as the action that calls them, and they must be placed under the views directory, according to the following directories structure: |-- Web |-- views |-- hello |-- world.html |-- world.js In the structure above, world.js and world.html represent our views. They are the base of our client-side, a eventListener and the markup. world.js BASIC STRUCTURE Hi.view(function($scope){ } The $scope variable represents your view scope. You can change the identifier to any word your wish(But never double underscores &quot;__&quot;). Me, I rather use an underscore &quot;_&quot;. This is the place you create your functions that should be executed uppon a call of some markup events like: ng-click, ng-blur and more... But those functions are not the only one that you can put here, you can create your own apart of any event and some functions are auto-called by Hi-Framework to help you track some states in your application. Hi.view(function($scope){ \/\/This function will be executed before the view is rendered $scope.$preLoad = function(){ } \/\/This function will be executed after the view is rendered $scope.$postLoad = function(){ } \/\/This function will be executed if you attemp to close your view $scope.$close = function(){ } \/\/This function will be executed whenever you decide to invoke it :) $scope.myFunction = function(){ } }); $preLoad viewScope.$preLoad is a function called before your html view is rendered. If you have any need of tracking this state, you may put your instructions here. If you(for any crazy reason) wish to make some changes in your markup before you render it, you may do so buy returning the modified markup in this viewScope.$preLoad function. The markup of the view will be passed as a param to $preLoad function. See this example: Hi.view(function($scope){ \/\/This function will be executed before the view is rendered $scope.$preLoad = function(viewMarkup){ \/\/My instructions here... alert(viewMarkup); \/\/Seeing the view's markup viewMarkup = &quot;&lt;h1&gt;Iam the new Markup!&lt;\/h1&gt;&quot;; \/\/modifying the markup return viewMarkup; \/\/returning the modified markup } }); $postLoad This function is called after your view is rendered. You should use this function to initialize scripts used in your view. Use it to do anything you wish to do after your view is loaded. See usages examples: Hi.view(function($scope){ \/\/This function will be executed before the view is rendered $scope.$preLoad = function(viewMarkup){ \/\/You can call frontiers here.. To get profile info $('.datatable').datatable(); \/\/initializing datatables $('.summernote').summernote(); \/\/initializing summernote wysiwyg \/\/Do as you wish } }); $close When the user attempts to exit the view he's displaying, this function is invoked. NOTE: WE DON'T CALL THIS EVENT WHEN THE USER RELOADS THE PAGE, CHANGES THE URL OR CLOSE THE BROWSER. Only when he attempts to exit using Hi redirect methods See examples: Hi.view(function($scope){ \/\/This function will be executed if you attemp to close your view $scope.$close = function(){ \/\/ Do anything! } }); $preventClose $scope.$preventClose is used to tell the Hi-Framework to not start redirecting when a user exits a view. The default value for this variable is false. If you wish to stop a user from exiting a views(may be to ask him if he's sure or to tell him to decide to save or not any data, or.. whatever you want) you should set the value of this variable to true; See the Example: Hi.view(function($scope){ $scope.$preventClose = true; \/\/This function will be executed if you attemp to close your view $scope.$close = function(promisse){ r = confirm(&quot;Do you really want to exit???? &quot;); if(r){ promisse.proceed(); }else{ \/\/You do whatever you want! That view isn't going anywhere } } }); The promisse.proceed() instruction will tell Hi-Framework to go on closing the view. world.html This is your markup! Designers work here! Remeber, Just HTML, No expression language. BASIC STRUCTURE &lt;mytag&gt;&lt;\/mytag&gt; \/\/Nothing is really required! We just don't care! What shouldn't you have here? You shouldn't include scripts, stylesheets or fonts (Althought you can! it works!) What should you put here? Your forms, images, videos, anything you what! This is where your application's user-interface leaves! Example: &lt;div&gt; &lt;form&gt; &lt;div class=&quot;panel-body p25 pb15&quot;&gt; &lt;div class=&quot;section row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;label for=&quot;firstname&quot; class=&quot;field prepend-icon&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;firstname&quot; id=&quot;firstname&quot; class=&quot;gui-input&quot; placeholder=&quot;First name...&quot;&gt; &lt;label for=&quot;firstname&quot; class=&quot;field-icon&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;\/i&gt; &lt;\/label&gt; &lt;\/label&gt; &lt;\/div&gt; &lt;!-- end section --&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;label for=&quot;lastname&quot; class=&quot;field prepend-icon&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;lastname&quot; id=&quot;lastname&quot; class=&quot;gui-input&quot; placeholder=&quot;Last name...&quot;&gt; &lt;label for=&quot;lastname&quot; class=&quot;field-icon&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;\/i&gt; &lt;\/label&gt; &lt;\/label&gt; &lt;\/div&gt; &lt;!-- end section --&gt; &lt;\/div&gt; &lt;!-- end section row section --&gt; &lt;\/div&gt; &lt;!-- end .form-body section --&gt; &lt;div class=&quot;panel-footer hidden&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;button btn-primary&quot;&gt;Post Comment&lt;\/button&gt; &lt;\/div&gt; &lt;!-- end .form-footer section --&gt; &lt;\/form&gt; &lt;\/div&gt; Working with the view's scope If your wish to use any data of your view's scope, you must use angular directives like: ng-click, ng-repeat, ng-disabled, ng-change If you dig about Angular 1.x, you will find some other that I don't know about. Just dig! Tips use ng-submit to submit your forms use ng-repeat to reapeat your data use {{variableName}} to display the value of an variable do Not invoke $postLoad,$preLoad or $close from here. Do not invoke them at all. Hi will do That! DEMOSTRATION Look at these view files: world.js Hi.view(function($scope){ $scope.myCars = [{name:&quot;Lamborguine&quot;,owner:&quot;Milton&quot;},{name:&quot;Ferrari&quot;,owner:&quot;Zacarias&quot;},{name:&quot;Bugati&quot;,owner:&quot;Pedro&quot;}]; $scope.theName = &quot;Hi-Framework&quot;; $scope.$postLoad = function(){ $scope.myValue = &quot;This One&quot;; } $scope.saveInformation = function(){ alert('Information Saved friends!'); } }); world.html &lt;div class=&quot;content&quot;&gt; &lt;h1&gt;Now I will shou you how {{theName}} works! What Hi? -{{myValue}} &lt;\/h1&gt; &lt;input type=&quot;text&quot; ng-model=&quot;myValue&quot;\/&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;car in myCars&quot;&gt;{{car.name}} owned by &lt;b&gt;{{car.owner}}&lt;\/b&gt; &lt;\/li&gt; &lt;ul&gt; &lt;button ng-click=&quot;saveInformation()&quot;&gt;Click here to save Nothing! (Cause this is a DEMO)&lt;\/button&gt; &lt;\/div&gt; Accecing the template scope Hi.view(function($scope){ $scope.$postLoad = function(){ alert(__.templateVariable); } }); The double underscores &quot;__&quot;, allow you to access the template scope. Embebed views This topic was assigned to &quot;Advanced Stuff&quot; section.","tags":"","url":"Core_Concepts\/Views.html"},{"title":"Templates","text":"What else can you learn about Templates???? I don't know, let's find out together. Let's make sure you know the basics about it, please read Creating the template in The Hello World App topic of the Getting Started section. So, welcome back(If you went away)! Remembering an Important rule about creating the html file of the template. The jquery script should always be included before the hi-framework script and they should both be placed as childs of head element. All caught up?? Now learn about the javascript file of the template index.js This file is designated template controller. As the javascript files on views, this file also handles events. Hi.template({ \/\/Handles HTTP Errors on redirect $onRedirectError : function(route,code){ \/\/Want to do anything about it? }, \/\/Template being initialized $init : function(){ \/\/Do anything here }, \/\/when the first view is loaded $startup : function(){ \/\/What about here? Any ideas?? Feel free }, \/\/PreLoad a view $onPreLoad : function(route,$scope,view){ \/\/You may need this... }, \/\/After a view postLoad $onPostLoad : function(route,$scope){ \/\/Ideas?? Well, no clue mate! }, \/\/When a view is closed $onClose : function(route){ \/\/Any use for this?? }, \/\/Staring a redirect $onRedirectStart : function(route){ \/\/I would display a loader here! Like: $('.my-loader').show(); }, \/\/Executed even in cases of redirect erros $onRedirectFinish : function(route){ \/\/I would hide my loader here! Like: $('.my-loader').hide(); }, \/*Frontiers Global Error Handles You may know frontiers by now, if you don't, you didn't read the Getting Started section. When you invoke a frontier, errors may show up: 500: Internal Server Error 404: Not found 403: Forbidden And more.. This is where you handle all that errors at once! IMPORTANT: This handlers are overridden by specific handlers(The ones wroten on the frontier call) *\/ $frontiers:{ forbbiden : function(call){ }, timeout : function(call){ }, offline : function(call){ }, interrupted : function(call){ }, catch : function(call,error){ }, overrequest : function(call){ }, finally : function(call){ } } }); About Frontiers Handlers The best way to catch exceptions globally is to set a message on the promise to be exhibited by the global handler. The global handler receives the promise as first argument to be Frontier1.getFullName(&quot;Jon&quot;, &quot;Snow&quot;) .try(function (data) { console.log(data); }).errorMessage = &quot;The method error message&quot;; The global handler would display an error message this way: $frontiers:{ catch : function(call,error){ alert(call.errorMessage); \/\/here you decide what to with the message } } Changing your template In hi.xml, add templates to web section &lt;web&gt; &lt;templates&gt; &lt;template&gt;otherTemplateName&lt;\/template&gt; &lt;\/templates&gt; &lt;\/web&gt; To apply a diferent Template, inject the fronEnd and use the methdod: frontEnd.setTemplate(&quot;second&quot;) \/\/receives a String with the name of the other template To get the current template use: frontEnd.getTemplate() \/\/returns a String with the current template name","tags":"","url":"Core_Concepts\/Templates.html"},{"title":"Frontiers","text":"The idea of naming this classes frontiers, was given by... Wait! You probrably don't care! Let's stick to the point. First rule before reading this: Read Frontiers basics in Getting Started section and About Frontiers Handlers back in Templates. Done? Scroll down! Things you should know about Frontiers You can modify template data here. Just Invoke FrontEnd as we did in Controllers Do not implement business logic here, create other classes for that. Leave this as only a bridge between server and client sides (This is just my advice) You should validate here all the information coming from client-side. client-side is not trustworthly. use javax.validation More about Invoking a Frontier Frontier1.method1(param1).try(function(data){ \/\/Get the result }).catch(function(exception){ console.error(exception);\/\/Something went went wrong! }).finally(function(){ \/\/Always executed }); Using bean validation in Frontiers Setting the Constrains Use bean validation on frontier parameters as the following example illustrates public boolean savePerson(@Min(2,message=&quot;age should me at least 2&quot;) int age, @Max(2.5) int height){ \/\/This will only be invoked if the params pass validation } Tip: If you are passing an object, you should make the validation in your entity classes, for each property you wish to validate. public class Person { private String name; @NotNull private int age; \/\/if the Frontier receives null for age, an javax.validation exception will be thrown } Handling validation erros in javascript The validation errors are sent back to the client (only the validation errors) and should handled on the catch callback, according to the following snippet: ... .catch(function(exception){ if(typeof exception==&quot;object&quot;){ \/\/This is a validation exception var errorMessages = exception.messages; } } Restricting Access of Frontiers Just use the @Granted annotation! Securing a frontier class @Frontier @ApplicationScoped @Granted({&quot;ROLE1&quot;,&quot;ROLE2&quot;}) \/\/Only users with these roles can access public class myFrontier{ } Securing a frontier method @Frontier @ApplicationScoped public class myFrontier{ @Granted(&quot;ROLE1&quot;) \/\/Only users with ROLE1 can access public Map method1(){ \/\/code comes here } @Granted(&quot;ROLE2&quot;) public Map method2(){ \/\/code comes here } @Granted({&quot;ROLE1&quot;,&quot;ROLE2&quot;}) public Map method3(){ \/\/code comes here } }","tags":"","url":"Core_Concepts\/Frontiers.html"},{"title":"Advanced Stuff","text":"Welcome Ready to dive deeper into Hi-Framework? Suit yourself!","tags":"","url":"Advanced_Stuff\/index.html"},{"title":"Files Upload","text":"Client-side ng-upload The ng-upload property\/directive is responsible for binding the input-file to the view's scope. When files are selected, they automatically get bound to the view's scope. They are immediatelly available to be used as frontier params. Your markup will look like this: &lt;input type=&quot;file&quot; ng-upload=&quot;profileImage&quot; \/&gt; How to access the selected file from javascript? $scope.profileImage; Time to send the file to the server Remember Frontiers? Well, then you know how to do it.. MyFrontier.method1($scope.profileImage,otherParam).try(function(result){ \/\/Use the result }).catch(function(exception){ \/\/Something went went wrong! }).finally(function(){ \/\/Always executed }); How to clear selected files? Clear any previously selected file delete $scope.profileImage; Callback once a file is selected? It's called onFiles and if you want the file information, pass a param named upload. &lt;input type=&quot;file&quot; ng-upload=&quot;profileImage&quot; onFiles=&quot;imageSelected(upload)&quot; \/&gt; Simple right? Go to your js view and create method named imageSelected, receive the upload param and get data like : Upload filename, file size, extension, etc.. Can you do multiple? Yeah.. U can! :) See this exemaple below: &lt;form&gt; &lt;!-- Multiple files--&gt; &lt;input type=&quot;file&quot; ng-upload=&quot;photos&quot; onFiles=&quot;photosSelected(upload)&quot; multiple\/&gt; &lt;!--Single file--&gt; &lt;input type=&quot;file&quot; ng-upload=&quot;photo&quot; onFiles=&quot;photoSelected(upload)&quot; \/&gt; &lt;\/form&gt; Server-side Multipart configurations must be set for the Hi-Framework's servlet in order to enable the upload feature. This is done via the web.xml configuration file. To set the multipart configuration we must register and map the Hi-Framework's servlet as the following example demostrates. Be aware that you must set the value HiServlet to the servlet-name property as the following example suggests and you must also set the same url-pattern value used in the example below. web.xml &lt;servlet&gt; &lt;servlet-name&gt;HiServlet&lt;\/servlet-name&gt; &lt;servlet-class&gt;mz.co.hi.web.DispatcherServlet&lt;\/servlet-class&gt; &lt;multipart-config&gt; &lt;location&gt;\/tmp\/&lt;\/location&gt; &lt;max-file-size&gt;80848820&lt;\/max-file-size&gt; &lt;max-request-size&gt;918018841&lt;\/max-request-size&gt; &lt;file-size-threshold&gt;1048576&lt;\/file-size-threshold&gt; &lt;\/multipart-config&gt; &lt;\/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HiServlet&lt;\/servlet-name&gt; &lt;url-pattern&gt;\/*&lt;\/url-pattern&gt; &lt;\/servlet-mapping&gt; Now it's time to retrieve the file you sent from the client-side. Create your frontier. @Frontier public class MyFrontier{ public Map method1(FileUpload fileParam, int otherParam){ \/\/some code here } } As you may have noticed in the Frontier above, your method can receive other params just as a normal Frontier method. Cause it is. :) The type for the file u are uploading must be mz.co.hi.web.frontier.FileUpload as in the example. Simple right? U can also handle multiple files @Frontier public class MyFrontier{ \/\/Single file upload public Map method1(FileUpload myFile, int otherParam){ \/\/some code here } \/\/Multiple files upload public Map someMethod(FileUpload[] myFiles, int otherParam){ \/\/some code here } } Okay.. U got the file.. Now what? Writting the file @Frontier public class MyFrontier{ public Map method1(FileUpload fileParam, int otherParam){ try { file.saveToFolder(&quot;\/your-directory\/&quot;); }catch (Exception ex){ System.err.println(&quot;Upload failed&quot;); ex.printStackTrace(); } } } Good to know! This implementation obligates Hi-framework to use form-data to transmit frontier invocations Params (http:\/\/java.sun.com\/javaee\/6\/docs\/api\/javax\/servlet\/http\/HttpServletRequest.html#getParts%28%29)","tags":"","url":"Advanced_Stuff\/Files_Upload.html"},{"title":"Hi Server Events Tracer","text":"Here I will show to you how you track some Events of you Hi App Create a Class named Whaterver you want, and place it on whatever package you want Implement TemplateLoadListener, ControllerCallsListener, FrontierCallsListener as in the example: @ApplicationScoped public class GenericEventsListener implements TemplateLoadListener, ControllerCallsListener, FrontierCallsListener { public void onTemplateLoad() { \/\/code here \/\/You can set Template data here.. Just Inject FrontEnd } public void preAction(ControllerRequestInterception args) { \/\/code here System.out.println(&quot;Before action call : &quot;+args.getClazz().getSimpleName()+&quot;\/&quot;+args.getMethod().getName()); } public void postAction(ControllerRequestInterception args) { \/\/code here System.out.println(&quot;Post action call : &quot;+args.getClazz().getSimpleName()+&quot;\/&quot;+args.getMethod().getName()); } public void preFrontier(FrontierRequestInterception args) { \/\/code here System.out.println(&quot;Pre frontier : &quot;+args.getClazz().getSimpleName()+&quot; : &quot;+args.getMethod().getName()); } public void postFrontier(FrontierRequestInterception args) { \/\/code here System.out.println(&quot;Post frontier : &quot;+args.getClazz().getSimpleName()+&quot; : &quot;+args.getMethod().getName()); } }","tags":"","url":"Advanced_Stuff\/Hi_Server_Events_Tracer.html"},{"title":"Internationalization","text":"What is it? It's a concept. It means adapting your Hi App to different languages. How does i18n(Internationalization) work in Hi? Well, we assume you have a default language (This is the applications's main language!) Imagine you want to build an CRUD app. How will you label your &quot;save&quot; button? Will it be &quot;save&quot;,&quot;salvar&quot;,&quot;sparen&quot;,..?? It will probably be your native language. And Then? Then we give your conditions to translate the messages of your default languages. You don't have to create language codes here. Just use your language naturally. If you enjoy creating codes, we do not forbird it. It's possible. How to start? (Directory Structure) Remember your web directory structure? |-- Web |-- WEB-INF |-- webroot |-- views |-- templateName.html |-- templateName.js Add a folder named i18n |-- Web |-- WEB-INF |-- i18n |-- webroot |-- views |-- templateName.html |-- templateName.js Inside i18n, you can put all of your translations. Let's assume your app has to be in portuguese and english. Since your default language is English(another assumption i'am making), you only need to have the translation to portuguese. |-- Web |-- WEB-INF |-- i18n |-- pt.json |-- views |-- templateName.html |-- templateName.js As you may have noticed above, translation files must be json's. NOTE: if you like to use language codes.. or you want some labels of the default language translated, you can create a file with that lannguage as well |-- Web |-- WEB-INF |-- i18n |-- en.json |-- pt.json |-- views |-- templateName.html |-- templateName.js And to apply that language by default, just go to hi.xml and set the default language as in the example below: &lt;app xmlns:xsi='http:\/\/www.w3.org\/2001\/XMLSchema-instance' xmlns='http:\/\/hi.co.mz\/XMLSchema' xsi:schemaLocation='http:\/\/hi.co.mz\/XMLSchema https:\/\/talk-code.github.io\/releases\/ns\/hi-1.0.xsd'&gt; &lt;default-lang&gt;en&lt;\/default-lang&gt; &lt;\/app&gt; This configuartion tells Hi Framework to apply the language &quot;en&quot; with translations in file &quot;your-web-directory\/i18n\/en.json&quot;. Translation files composition As I tould you before, translation files are JSON's. As the key, you have the label (In your default language) As the value, you have the corresponding translation See example below: App default language: English Translating to: Portuguese Filename: pt.json { &quot;Previous&quot;:&quot;Anterior&quot;, &quot;Next&quot;:&quot;Pr\u00c3\u00b3ximo&quot; } Markup Translation We created an angular directive(translate) to help you translate your app. See the markup below: &lt;label&gt;Your name&lt;\/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Type your name..&quot; \/&gt; It changes to this: MODE 1 (Translating labels of default language) &lt;label translate&gt;Your name&lt;\/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Type your name..&quot; translate-placeholder translate \/&gt; What happened here? when you put translate porperty in your element, Hi Framework looks for another porperty with a name starting with &quot;translate-&quot;. If it don't find it, It translates the inner HTML of your element.(case of element label) If it find's it, it translate watever porperty name come after the hyphen. In the example above, &quot;placeholder&quot; will be translated. Got it? So, how does the translation file looks like? { &quot;Your name&quot;:&quot;O seu nome&quot;, &quot;Type your name..&quot;:&quot;Escreva o seu nome..&quot; } MODE 2 (Using translation codes) &lt;label translate=&quot;code-for-your-name&quot;&gt;Your name&lt;\/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Type your name..&quot; translate-placeholder translate=&quot;code-for-type-your-name&quot; \/&gt; WTF is this? Well, that are your codes mate. That way, the translation file will look like: { &quot;code-for-your-name&quot;:&quot;O seu nome&quot;, &quot;code-for-type-your-name&quot;:&quot;Escreva o seu nome..&quot; } Couldn't be simpler right?? I know! :) Javascript values Translation We created this function __t(); Yeah! two underscores + t. So wherever you are (in a $scope or not), it just works! See example: Hi.view(function($scope){ _.savePerson = function(){ alert(&quot;Person sucessfully saved!&quot;); \/\/Simple alert alert(__t(&quot;Person sucessfully saved!&quot;)); \/\/Translatable alert alert(__t(&quot;Person sucessfully saved!&quot;,&quot;person-saved-message-code&quot;)); \/\/Translatable alert with translation code } } That's it.. Oh! and you can also have something like this: &lt;div ng-show=&quot;isPersonSaved&quot;&gt;{{__t(&quot;Person sucessfully saved!&quot;)}}&lt;\/div&gt; That div will only appear when the value of the variable isPersonSaved is true. (But that's angular, not Hi) Changing the language Your app is running and you are seeing all content in just one language. You want to change the language to some other.. Well, it's simple. This is done in the server side, you must have a controller action or a frontier method ready, in order to get this done. Go to your controller action\/frontier method, and call the method setLanguage of mz.co.hi.web.FrontEnd as in the example. frontEnd.setLanguage(&quot;pt&quot;); With this instruction, Hi Framework will load translations of i18n\/pt.json and apply in your application. (Hi reloads your application in this process)","tags":"","url":"Advanced_Stuff\/Internationalization.html"},{"title":"FrontEnd Class","text":"What is FrontEnd? It's your way of manipulating the Client-Side from Server-Side. What can you do? Well after Injecting the FrontEnd, you can start making your manipulation. see injection example: @Inject FrontEnd frontEnd; The FrontEnd class fully qualified name is : mz.co.hi.web.FrontEnd Redirect to another URL frontEnd.ajaxRedirect(&quot;controller\/action&quot;); Set or Get Template Data frontEnd.setTemplateData(yourMap); \/\/key will be variable names and values will be variable values frontEnd.getTemplateData(); \/\/returns a java.Util.Map Set or Get Language frontEnd.setLanguage(&quot;pt&quot;); \/\/receives a String with the filename(without the extension) of your language in i18n folder. frontEnd.getLanguage(); \/\/returns a String Seeing request type frontEnd.isRequestAjax() \/\/boolean Get or Set Template frontEnd.setTemplate(&quot;second&quot;) \/\/receives a String with the name of the other template frontEnd.getTemplate() \/\/returns a String with the current template name","tags":"","url":"Advanced_Stuff\/FrontEnd_Class.html"},{"title":"Request Context","text":"The RequestContext fully qualified name is : mz.co.hi.web.RequestContext What can you do with it? After Injecting, as in the following example, you can do a lot of stuff. @Inject RequestContext requestContext; print data in browser and stop execution requestContext.echo(&quot;Wathever&quot;); Retrieve the application URL requestContext.getBaseURL(); \/\/returns String Retrieve the HttpServletRequest object requestContext.Request(); \/\/returns HttpServletRequest Retrieve the HttpServletResponse object requestContext.Reponse(); \/\/returns HttpServletResponse Retrieve route URL requestContext.getRouteURL(); \/\/returns String Retrieve full URL requestContext.getURL(); \/\/returns String","tags":"","url":"Advanced_Stuff\/Request_Context.html"},{"title":"App Configurations","text":"PRODUCTION or DEVELOPMENT MODE &lt;deployment-mode&gt;DEVELOPMENT&lt;\/deployment-mode&gt; \/\/Or PRODUCTION Default Language &lt;default-lang&gt;en&lt;\/default-lang&gt; \/\/Oy any of the other Translation your may have Entrance route &lt;web&gt; &lt;welcome-url&gt;people\/create&lt;\/welcome-url&gt; \/\/Or any other route &lt;\/web&gt;","tags":"","url":"Advanced_Stuff\/App_Configurations.html"},{"title":"FAQS","text":"Can Hi be integrated with other Template Engines rather than Angular? Not for now. But, Thats the plan. We may start with Vue.js Who built Hi? A group of two very ambitious african coders. You can read about them here Does Hi implement JSF's binding mechanism? Nop. It doesnt and its not even in the plans to put it there.","tags":"","url":"FAQS\/index.html"}]}